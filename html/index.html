<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>textwolf: textwolf C++ template library for iterating on XML content</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">textwolf
   &#160;<span id="projectnumber">0.2</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">textwolf C++ template library for iterating on XML content </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="TextScanner"></a>
Iterating on unicode characters</h2>
<p>The template class <a class="el" href="classtextwolf_1_1TextScanner.html" title="Reader for scanning the input character by character.">textwolf::TextScanner</a> defines a character by character iterator on a text source. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="xmlscanner_8hpp.html" title="XML parser iterator interface for processing the XML elements one by one.">textwolf/xmlscanner.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cstringiterator_8hpp.html" title="textwolf iterator on strings">textwolf/cstringiterator.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="charset_8hpp.html" title="Character set encodings already implemented in textwolf.">textwolf/charset.hpp</a>&quot;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="TextScanner_8cpp.html#a28bd102e9eb60edf07c5c994ee0ce755">output</a>( <span class="keyword">const</span> std::string&amp; str)
{
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1TextScanner.html" title="Reader for scanning the input character by character.">textwolf::TextScanner&lt;textwolf::CStringIterator,textwolf::charset::UTF8&gt;</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#afb40694b6503fea09f1c92509c6409a7">Scanner</a>;
        Scanner itr(str);
        
        <span class="keywordflow">for</span> (; *itr; ++itr)
        {
                std::cout &lt;&lt; std::hex &lt;&lt; (<span class="keywordtype">unsigned</span> int)*itr &lt;&lt; std::dec &lt;&lt; std::endl;
        }
}
</pre></div><h2><a class="anchor" id="XMLScanner"></a>
Iterating on XML elements</h2>
<p>The template class <a class="el" href="classtextwolf_1_1XMLScanner.html" title="XML scanner template that adds the functionality to the statemachine base definition.">textwolf::XMLScanner</a> defines an iterator on XML tokens. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="xmlscanner_8hpp.html" title="XML parser iterator interface for processing the XML elements one by one.">textwolf/xmlscanner.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="charset_8hpp.html" title="Character set encodings already implemented in textwolf.">textwolf/charset.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cstringiterator_8hpp.html" title="textwolf iterator on strings">textwolf/cstringiterator.hpp</a>&quot;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="TextScanner_8cpp.html#a28bd102e9eb60edf07c5c994ee0ce755">output</a>( <span class="keyword">const</span> std::string&amp; str)
{
        <span class="keyword">typedef</span> <a class="code" href="structtextwolf_1_1charset_1_1UTF8.html" title="character set encoding UTF-8">textwolf::charset::UTF8</a> MyEncoding;
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1CStringIterator.html" title="Input iterator on a constant string returning null characters after EOF as required by textwolf scann...">textwolf::CStringIterator</a> MyIterator;
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1XMLScanner.html" title="XML scanner template that adds the functionality to the statemachine base definition.">textwolf::XMLScanner&lt;MyIterator,MyEncoding,MyEncoding,std::string&gt;</a> MyScanner;

        <a class="code" href="classtextwolf_1_1CStringIterator.html" title="Input iterator on a constant string returning null characters after EOF as required by textwolf scann...">textwolf::CStringIterator</a> si( str);
        MyScanner scan( si);
        MyScanner::iterator itr = scan.begin(), end = scan.end();

        <span class="keywordflow">for</span> (; itr != end; ++itr)
        {
                <span class="keywordflow">if</span> (itr-&gt;error())
                {
                        <span class="keywordflow">throw</span> std::runtime_error( std::string(<span class="stringliteral">&quot;xml error: &quot;</span>) + itr-&gt;error());
                }
                std::string elem = std::string(itr-&gt;content(),itr-&gt;size());
                std::cout &lt;&lt; itr-&gt;name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; elem &lt;&lt; std::endl;
        }
}
</pre></div><h2><a class="anchor" id="XMLPathSelect"></a>
Iterating on XML path expression matches</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="xmlscanner_8hpp.html" title="XML parser iterator interface for processing the XML elements one by one.">textwolf/xmlscanner.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="xmlpathselect_8hpp.html" title="Context of running automaton selecting path expressions from an XML iterator.">textwolf/xmlpathselect.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cstringiterator_8hpp.html" title="textwolf iterator on strings">textwolf/cstringiterator.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="charset_8hpp.html" title="Character set encodings already implemented in textwolf.">textwolf/charset.hpp</a>&quot;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keywordtype">void</span> <a class="code" href="TextScanner_8cpp.html#a28bd102e9eb60edf07c5c994ee0ce755">output</a>( <span class="keyword">const</span> std::string&amp; str)
{
        <span class="keyword">typedef</span> <a class="code" href="structtextwolf_1_1charset_1_1UTF8.html" title="character set encoding UTF-8">textwolf::charset::UTF8</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#a6b5f94c96386e389a4f841bdd62d6632">Encoding</a>;
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1CStringIterator.html" title="Input iterator on a constant string returning null characters after EOF as required by textwolf scann...">textwolf::CStringIterator</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#a758b9ff9e6df178bc98b411e2dc96bb7">Iterator</a>;
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1XMLScanner.html" title="XML scanner template that adds the functionality to the statemachine base definition.">textwolf::XMLScanner&lt;Iterator,Encoding,Encoding,std::string&gt;</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#afb40694b6503fea09f1c92509c6409a7">Scanner</a>;
        <span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1XMLPathSelect.html" title="XML path select template.">textwolf::XMLPathSelect&lt;Encoding&gt;</a> Selector;

        <a class="code" href="classtextwolf_1_1XMLPathSelectAutomaton.html" title="Automaton to define XML path expressions and assign types (int values) to them.">textwolf::XMLPathSelectAutomaton&lt;Encoding&gt;</a> atm;
        (*atm)[<span class="stringliteral">&quot;address&quot;</span>](<span class="stringliteral">&quot;name&quot;</span>) = 1;   <span class="comment">//... assign 1 to matches of /address/@name</span>
        (*atm)[<span class="stringliteral">&quot;address&quot;</span>](<span class="stringliteral">&quot;street&quot;</span>) = 2; <span class="comment">//... assign 2 to matches of /address/@street</span>

        Scanner scanner( str);
        Selector selector( &amp;atm);

        <span class="comment">// Fetch the input elements, feed them to the selector and iterate on the result dropping out:</span>
        <a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator.html" title="input iterator for iterating on the output of an XML scanner">Scanner::iterator</a> itr = scanner.begin(), end = scanner.end();
        <span class="keywordflow">for</span> (; itr != end; itr++)
        {
                <span class="keywordflow">if</span> (itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#ae651c73e0fcf5d2787ad69b0d7284805" title="Return the current error.">error</a>())
                {
                        <span class="keywordflow">throw</span> std::runtime_error( std::string(<span class="stringliteral">&quot;xml error: &quot;</span>) + itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#ae651c73e0fcf5d2787ad69b0d7284805" title="Return the current error.">error</a>());
                }
                std::string elem = std::string( itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#a78656ff71a3070194b38a5ebca1511a9" title="Value of the current element.">content</a>(), itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#aa4abb5884ced96b5172793b2a26b472d" title="Size of the value of the current element in bytes.">size</a>());
                Selector::iterator si = selector.push( itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#aafcf583ea1902e0069110c6eb8668ae8" title="Type of the current element.">type</a>(), elem), se = selector.end();

                <span class="keywordflow">for</span> (; si!=se; si++)
                {
                        std::cout &lt;&lt; *si &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#a74443b15cdad5188fbfece6c22bf4aea" title="Type of the current element as string.">name</a>() &lt;&lt; elem &lt;&lt; std::endl;
                }
        }
}
</pre></div><h2><a class="anchor" id="XMLScanner_chunkwise"></a>
Iterating on XML elements in chunkwise feeded source</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="xmlscanner_8hpp.html" title="XML parser iterator interface for processing the XML elements one by one.">textwolf/xmlscanner.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="charset_8hpp.html" title="Character set encodings already implemented in textwolf.">textwolf/charset.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="sourceiterator_8hpp.html" title="textwolf byte source iterator template">textwolf/sourceiterator.hpp</a>&quot;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;setjmp.h&gt;</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning (disable:4611)</span>
<span class="preprocessor"></span><span class="comment">//... on Windows you have on to disable warning C4611 (we know what we are doing)</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="structtextwolf_1_1charset_1_1UTF8.html" title="character set encoding UTF-8">textwolf::charset::UTF8</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#a6b5f94c96386e389a4f841bdd62d6632">Encoding</a>;
<span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1SrcIterator.html" title="Input iterator as source for the XML scanner with the possibility of being fed chunk by chunk...">textwolf::SrcIterator</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#a758b9ff9e6df178bc98b411e2dc96bb7">Iterator</a>;
<span class="keyword">typedef</span> <a class="code" href="classtextwolf_1_1XMLScanner.html" title="XML scanner template that adds the functionality to the statemachine base definition.">textwolf::XMLScanner&lt;Iterator,Encoding,Encoding,std::string&gt;</a> <a class="code" href="XMLScanner__chunkwise_8cpp.html#afb40694b6503fea09f1c92509c6409a7">Scanner</a>;

<span class="keywordtype">bool</span> <a class="code" href="TextScanner_8cpp.html#a28bd102e9eb60edf07c5c994ee0ce755">output</a>( Scanner&amp; scan, <span class="keyword">const</span> <span class="keywordtype">char</span>* chunk, std::size_t chunksize)
{
        jmp_buf eom;
        scan.<a class="code" href="classtextwolf_1_1XMLScanner.html#a8bf316457211f3a7a4b12c4ad1f31ec0" title="Assign something to the source iterator while keeping the state.">setSource</a>( <a class="code" href="XMLScanner__chunkwise_8cpp.html#a758b9ff9e6df178bc98b411e2dc96bb7">Iterator</a>( chunk, chunksize, &amp;eom));

        <span class="keywordflow">if</span> (setjmp(eom) != 0)
        {
                <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">//... do call the function with the next chunk</span>
        }
        <a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator.html" title="input iterator for iterating on the output of an XML scanner">Scanner::iterator</a> itr = scan.<a class="code" href="classtextwolf_1_1XMLScanner.html#a2fa61ddab30002d7ced93764066b2a05" title="Get begin iterator.">begin</a>(), end = scan.<a class="code" href="classtextwolf_1_1XMLScanner.html#a5c83c190269593de0aa7426449db149f" title="Get the pointer to the end of content.">end</a>();

        <span class="keywordflow">for</span> (; itr != end; ++itr)
        {
                <span class="keywordflow">if</span> (itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#ae651c73e0fcf5d2787ad69b0d7284805" title="Return the current error.">error</a>())
                {
                        <span class="keywordflow">throw</span> std::runtime_error( std::string(<span class="stringliteral">&quot;xml error: &quot;</span>) + itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#ae651c73e0fcf5d2787ad69b0d7284805" title="Return the current error.">error</a>());
                }
                std::string elem = std::string( itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#a78656ff71a3070194b38a5ebca1511a9" title="Value of the current element.">content</a>(),itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#aa4abb5884ced96b5172793b2a26b472d" title="Size of the value of the current element in bytes.">size</a>());
                std::cout &lt;&lt; itr-&gt;<a class="code" href="classtextwolf_1_1XMLScanner_1_1iterator_1_1Element.html#a74443b15cdad5188fbfece6c22bf4aea" title="Type of the current element as string.">name</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; elem &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div><p>The template class <a class="el" href="classtextwolf_1_1XMLPathSelect.html" title="XML path select template.">textwolf::XMLPathSelect</a> fed with XML tokens lets you iterate on matching XML path expressions</p>
<h2><a class="anchor" id="Interface"></a>
Adding new character set encodings</h2>
<p>Besides the supported character set encodings listed in "textwolf/charset.hpp" you can define your own by implementing a class as shown as <a class="el" href="structtextwolf_1_1charset_1_1Interface.html" title="This interface has to be implemented for a character set encoding.">textwolf::charset::Interface</a>.</p>
<h2><a class="anchor" id="SrcIterator"></a>
Source iterators</h2>
<ul>
<li>Use 'char*' as iterator type</li>
<li>Use <a class="el" href="classtextwolf_1_1CStringIterator.html" title="Input iterator on a constant string returning null characters after EOF as required by textwolf scann...">textwolf::CStringIterator</a> as iterator on a complete std::string</li>
<li>Use <a class="el" href="classtextwolf_1_1IStreamIterator.html" title="Input iterator on an STL input stream.">textwolf::IStreamIterator</a> as iterator on a std::istream</li>
<li>Use <a class="el" href="classtextwolf_1_1SrcIterator.html" title="Input iterator as source for the XML scanner with the possibility of being fed chunk by chunk...">textwolf::SrcIterator</a> as iterator able to do chunk by chunk processing </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 16 2014 12:56:13 for textwolf by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
