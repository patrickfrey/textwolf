.TH "textwolf::XMLPathSelect::Array" 3 "14 Aug 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::XMLPathSelect::Array \- 
.PP
static array of POD types. I decided to implement it on my own though using boost::array would maybe be better.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBtextwolf::throws_exception\fP.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBArray\fP (unsigned int p_maxSize)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fB~Array\fP ()"
.br
.RI "\fIDestructor. \fP"
.ti -1c
.RI "void \fBpush_back\fP (const Element &elem)"
.br
.RI "\fIAppend one element. \fP"
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.RI "\fIRemove one element from the end. \fP"
.ti -1c
.RI "Element & \fBoperator[]\fP (unsigned int idx)"
.br
.RI "\fIAccess element by index. \fP"
.ti -1c
.RI "Element & \fBback\fP ()"
.br
.RI "\fIGet a reference of the element at the end of the array. \fP"
.ti -1c
.RI "void \fBresize\fP (unsigned int p_size)"
.br
.RI "\fIResize of the array. \fP"
.ti -1c
.RI "unsigned int \fBsize\fP () const "
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Element * \fBm_ar\fP"
.br
.RI "\fIpointer to elements \fP"
.ti -1c
.RI "unsigned int \fBm_size\fP"
.br
.RI "\fIfill size (number of elements inserted) \fP"
.ti -1c
.RI "unsigned int \fBm_maxSize\fP"
.br
.RI "\fIallocation size (space reserved for this number of elements) \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>>template<typename Element> class textwolf::XMLPathSelect< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::Array< Element >"
static array of POD types. I decided to implement it on my own though using boost::array would maybe be better. 

\fBTemplate Parameters:\fP
.RS 4
\fIElement\fP element type of the array 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::\fBArray\fP (unsigned int p_maxSize)\fC [inline]\fP"
.PP
Constructor. \fBParameters:\fP
.RS 4
\fIp_maxSize\fP allocation size (number of elements) to reserve 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::~\fBArray\fP ()\fC [inline]\fP"
.PP
Destructor. 
.SH "Member Function Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> Element& \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::back ()\fC [inline]\fP"
.PP
Get a reference of the element at the end of the array. \fBReturns:\fP
.RS 4
element reference 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> bool \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::empty () const\fC [inline]\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> Element& \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::operator[] (unsigned int idx)\fC [inline]\fP"
.PP
Access element by index. \fBParameters:\fP
.RS 4
\fIidx\fP index of the element starting with 0 
.RE
.PP
\fBReturns:\fP
.RS 4
element reference 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::pop_back ()\fC [inline]\fP"
.PP
Remove one element from the end. 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::push_back (const Element & elem)\fC [inline]\fP"
.PP
Append one element. \fBParameters:\fP
.RS 4
\fIelem\fP element to append 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::resize (unsigned int p_size)\fC [inline]\fP"
.PP
Resize of the array. \fBParameters:\fP
.RS 4
\fIp_size\fP new array size 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> unsigned int \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::size () const\fC [inline]\fP"
.SH "Member Data Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> Element* \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::\fBm_ar\fP\fC [private]\fP"
.PP
pointer to elements 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> unsigned int \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::\fBm_maxSize\fP\fC [private]\fP"
.PP
allocation size (space reserved for this number of elements) 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> template<typename Element> unsigned int \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBArray\fP< Element >::\fBm_size\fP\fC [private]\fP"
.PP
fill size (number of elements inserted) 

.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
