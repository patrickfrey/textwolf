.TH "textwolf::charset::UTF16" 3 "14 Aug 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::charset::UTF16 \- 
.PP
Character set \fBUTF16\fP (little/big endian).  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <textwolf.hpp>\fP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static unsigned int \fBasize\fP ()"
.br
.ti -1c
.RI "static unsigned int \fBsize\fP (const char *buf)"
.br
.ti -1c
.RI "static char \fBachar\fP (const char *buf)"
.br
.ti -1c
.RI "static \fBUChar\fP \fBvalue\fP (const char *buf)"
.br
.RI "\fIparses a unicode character from its serialization in a buffer \fP"
.ti -1c
.RI "template<class Buffer_ > static void \fBprint\fP (\fBUChar\fP ch, Buffer_ &buf)"
.br
.RI "\fIprints a unicode character to a buffer \fP"
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum { \fBLSB\fP = (encoding==ByteOrder::BE), \fBMSB\fP = (encoding==ByteOrder::LE), \fBPrint1shift\fP = (encoding==ByteOrder::BE)?8:0, \fBPrint2shift\fP = (encoding==ByteOrder::LE)?8:0 }"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<int encoding> class textwolf::charset::UTF16< encoding >"
Character set \fBUTF16\fP (little/big endian). 

\fBTemplate Parameters:\fP
.RS 4
\fIencoding\fP \fBByteOrder::LE\fP or \fBByteOrder::BE\fP 
.RE
.PP
\fBRemarks:\fP
.RS 4
BOM character sequences are not interpreted as such and byte swapping is not done implicitely It is left to the caller to detect BOM or its inverse and to switch the iterator. 
.PP
See http://en.wikipedia.org/wiki/UTF-16/UCS-2: ... If the endian architecture of the decoder matches that of the encoder, the decoder detects the 0xFEFF value, but an opposite-endian decoder interprets the BOM as the non-character value U+FFFE reserved for this purpose. This incorrect result provides a hint to perform byte-swapping for the remaining values. If the BOM is missing, the standard says that big-endian encoding should be assumed.... 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "template<int encoding> anonymous enum\fC [private]\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fILSB \fP\fP
least significant byte index (0 or 1) 
.TP
\fB\fIMSB \fP\fP
most significant byte index (0 or 1) 
.TP
\fB\fIPrint1shift \fP\fP
value to shift with to get the 1st character to print 
.TP
\fB\fIPrint2shift \fP\fP
value to shift with to get the 2nd character to print 
.SH "Member Function Documentation"
.PP 
.SS "template<int encoding> static char \fBtextwolf::charset::UTF16\fP< encoding >::achar (const char * buf)\fC [inline, static]\fP"
.SS "template<int encoding> static unsigned int \fBtextwolf::charset::UTF16\fP< encoding >::asize ()\fC [inline, static]\fP"
.SS "template<int encoding> template<class Buffer_ > static void \fBtextwolf::charset::UTF16\fP< encoding >::print (\fBUChar\fP ch, Buffer_ & buf)\fC [inline, static]\fP"
.PP
prints a unicode character to a buffer \fBTemplate Parameters:\fP
.RS 4
\fIBuffer_\fP STL back insertion sequence 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIch\fP character to print 
.br
\fIbuf\fP buffer to print to 
.RE
.PP

.SS "template<int encoding> static unsigned int \fBtextwolf::charset::UTF16\fP< encoding >::size (const char * buf)\fC [inline, static]\fP"
.SS "template<int encoding> static \fBUChar\fP \fBtextwolf::charset::UTF16\fP< encoding >::value (const char * buf)\fC [inline, static]\fP"
.PP
parses a unicode character from its serialization in a buffer \fBParameters:\fP
.RS 4
\fIbuf\fP buffer to parse the character from 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the unicode character 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
