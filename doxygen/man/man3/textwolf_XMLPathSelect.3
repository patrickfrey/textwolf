.TH "textwolf::XMLPathSelect" 3 "14 Aug 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::XMLPathSelect \- 
.PP
XML path select template.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <textwolf.hpp>\fP
.PP
Inherits \fBtextwolf::throws_exception\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBArray\fP"
.br
.RI "\fIstatic array of POD types. I decided to implement it on my own though using boost::array would maybe be better. \fP"
.ti -1c
.RI "class \fBContext\fP"
.br
.RI "\fI\fBState\fP variables without stacks of the automaton. \fP"
.ti -1c
.RI "class \fBEnd\fP"
.br
.RI "\fIend of input iterator for the output of this \fBXMLScanner\fP \fP"
.ti -1c
.RI "class \fBiterator\fP"
.br
.RI "\fIinput iterator for the output of this \fBXMLScanner\fP \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef OutputBuffer_ \fBOutputBuffer\fP"
.br
.ti -1c
.RI "typedef \fBXMLPathSelectAutomaton\fP< OutputCharSet_ > \fBThisXMLPathSelectAutomaton\fP"
.br
.ti -1c
.RI "typedef \fBXMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, \fBOutputBuffer\fP, EntityMap_ > \fBThisXMLScanner\fP"
.br
.ti -1c
.RI "typedef \fBXMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, \fBOutputBuffer\fP, EntityMap_ > \fBThisXMLPathSelect\fP"
.br
.ti -1c
.RI "typedef EntityMap_ \fBEntityMap\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBXMLPathSelect\fP (const \fBThisXMLPathSelectAutomaton\fP *p_atm, InputIterator &p_src, \fBOutputBuffer\fP &obuf, const \fBEntityMap\fP &entityMap)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBXMLPathSelect\fP (const \fBThisXMLPathSelectAutomaton\fP *p_atm, InputIterator &p_src, \fBOutputBuffer\fP &obuf)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBXMLPathSelect\fP (const \fBXMLPathSelect\fP &o)"
.br
.RI "\fICopy constructor. \fP"
.ti -1c
.RI "void \fBsetOutputBuffer\fP (\fBOutputBuffer\fP &p_outputBuf)"
.br
.RI "\fIRedefine the buffer to use for output. \fP"
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP (bool skipToFirst=true)"
.br
.RI "\fIGet the start iterator. \fP"
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.RI "\fIGet the end of content marker. \fP"
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef \fBThisXMLPathSelectAutomaton::Mask\fP \fBMask\fP"
.br
.ti -1c
.RI "typedef \fBThisXMLPathSelectAutomaton::Token\fP \fBToken\fP"
.br
.ti -1c
.RI "typedef \fBThisXMLPathSelectAutomaton::Hash\fP \fBHash\fP"
.br
.ti -1c
.RI "typedef \fBThisXMLPathSelectAutomaton::State\fP \fBState\fP"
.br
.ti -1c
.RI "typedef \fBThisXMLPathSelectAutomaton::Scope\fP \fBScope\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBexpand\fP (int stateidx)"
.br
.RI "\fIActivate a state by index. \fP"
.ti -1c
.RI "void \fBinitProcessElement\fP (\fBXMLScannerBase::ElementType\fP type, const char *key, int keysize)"
.br
.RI "\fIDeclares the currently processed element of the \fBXMLScanner\fP input. By calling fetch we get the output elements from it. \fP"
.ti -1c
.RI "void \fBproduce\fP (unsigned int tokenidx, const \fBState\fP &st)"
.br
.RI "\fIproduce an element adressed by token index \fP"
.ti -1c
.RI "int \fBmatch\fP (unsigned int tokenidx)"
.br
.RI "\fIcheck if an active token addressed by index matches to the currently processed element \fP"
.ti -1c
.RI "int \fBfetch\fP ()"
.br
.RI "\fIfetch the next matching element \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBThisXMLScanner\fP \fBscan\fP"
.br
.RI "\fIXML Scanner for fetching elements for the automaton input. \fP"
.ti -1c
.RI "const \fBThisXMLPathSelectAutomaton\fP * \fBatm\fP"
.br
.RI "\fIXML select automaton used. \fP"
.ti -1c
.RI "\fBArray\fP< \fBScope\fP > \fBscopestk\fP"
.br
.RI "\fIstack of scopes opened \fP"
.ti -1c
.RI "\fBArray\fP< unsigned int > \fBfollows\fP"
.br
.RI "\fIindices of tokens active in all descendant scopes \fP"
.ti -1c
.RI "\fBArray\fP< int > \fBtriggers\fP"
.br
.RI "\fItriggered elements \fP"
.ti -1c
.RI "\fBArray\fP< \fBToken\fP > \fBtokens\fP"
.br
.RI "\fIlist of waiting tokens \fP"
.ti -1c
.RI "\fBContext\fP \fBcontext\fP"
.br
.RI "\fIstate variables without stacks of the automaton \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> class textwolf::XMLPathSelect< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >"
XML path select template. 

\fBTemplate Parameters:\fP
.RS 4
\fIInputIterator\fP input iterator with ++ and read only * returning 0 als last character of the input 
.br
\fIInputCharSet_\fP character set encoding of the input, read as stream of bytes 
.br
\fIOutputCharSet_\fP character set encoding of the output, printed as string of the item type of the character set, 
.br
\fIOutputBuffer_\fP buffer for output with STL back insertion sequence interface (e.g. std::string,std::vector<char>,\fBtextwolf::StaticBuffer\fP) 
.br
\fIEntityMap_\fP STL like map from ASCII const char* to UChar 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef EntityMap_ \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBEntityMap\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBThisXMLPathSelectAutomaton::Hash\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBHash\fP\fC [private]\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBThisXMLPathSelectAutomaton::Mask\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBMask\fP\fC [private]\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef OutputBuffer_ \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBOutputBuffer\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBThisXMLPathSelectAutomaton::Scope\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBScope\fP\fC [private]\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBThisXMLPathSelectAutomaton::State\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBState\fP\fC [private]\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBXMLPathSelect\fP<InputIterator,InputCharSet_,OutputCharSet_,\fBOutputBuffer\fP,EntityMap_> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBThisXMLPathSelect\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBXMLPathSelectAutomaton\fP<OutputCharSet_> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBThisXMLPathSelectAutomaton\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBXMLScanner\fP<InputIterator,InputCharSet_,OutputCharSet_,\fBOutputBuffer\fP,EntityMap_> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBThisXMLScanner\fP"
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> typedef \fBThisXMLPathSelectAutomaton::Token\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBToken\fP\fC [private]\fP"
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLPathSelect\fP (const \fBThisXMLPathSelectAutomaton\fP * p_atm, InputIterator & p_src, \fBOutputBuffer\fP & obuf, const \fBEntityMap\fP & entityMap)\fC [inline]\fP"
.PP
Constructor. \fBParameters:\fP
.RS 4
\fIp_atm\fP read only ML path select automaton reference 
.br
\fIp_src\fP source input iterator to process 
.br
\fIobuf\fP reference to buffer to use for the output elements (STL back insertion sequence interface) 
.br
\fIentityMap\fP read only map of named entities to expand 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLPathSelect\fP (const \fBThisXMLPathSelectAutomaton\fP * p_atm, InputIterator & p_src, \fBOutputBuffer\fP & obuf)\fC [inline]\fP"
.PP
Constructor. \fBParameters:\fP
.RS 4
\fIp_atm\fP read only ML path select automaton reference 
.br
\fIp_src\fP source input iterator to process 
.br
\fIobuf\fP reference to buffer to use for the output elements (STL back insertion sequence interface) 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLPathSelect\fP (const \fBXMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ > & o)\fC [inline]\fP"
.PP
Copy constructor. \fBParameters:\fP
.RS 4
\fIo\fP element to copy 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::begin (bool skipToFirst = \fCtrue\fP)\fC [inline]\fP"
.PP
Get the start iterator. \fBReturns:\fP
.RS 4
iterator pointing to the first of the selected XML path elements 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::end ()\fC [inline]\fP"
.PP
Get the end of content marker. \fBReturns:\fP
.RS 4
iterator as end of content marker 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::expand (int stateidx)\fC [inline, private]\fP"
.PP
Activate a state by index. \fBParameters:\fP
.RS 4
\fIstateidx\fP index of the state to activate 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> int \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::fetch ()\fC [inline, private]\fP"
.PP
fetch the next matching element \fBReturns:\fP
.RS 4
type of the matching element 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::initProcessElement (\fBXMLScannerBase::ElementType\fP type, const char * key, int keysize)\fC [inline, private]\fP"
.PP
Declares the currently processed element of the \fBXMLScanner\fP input. By calling fetch we get the output elements from it. \fBParameters:\fP
.RS 4
\fItype\fP type of the current element processed 
.br
\fIkey\fP current element processed 
.br
\fIkeysize\fP size of the key in bytes 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> int \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::match (unsigned int tokenidx)\fC [inline, private]\fP"
.PP
check if an active token addressed by index matches to the currently processed element \fBParameters:\fP
.RS 4
\fItokenidx\fP index of the token in the list of active tokens 
.RE
.PP
\fBReturns:\fP
.RS 4
matching token type 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::produce (unsigned int tokenidx, const \fBState\fP & st)\fC [inline, private]\fP"
.PP
produce an element adressed by token index \fBParameters:\fP
.RS 4
\fItokenidx\fP index of the token in the list of active tokens 
.br
\fIst\fP state from which the expand was triggered 
.RE
.PP

.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> void \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::setOutputBuffer (\fBOutputBuffer\fP & p_outputBuf)\fC [inline]\fP"
.PP
Redefine the buffer to use for output. \fBParameters:\fP
.RS 4
\fIp_outputBuf\fP buffer to use for output 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> const \fBThisXMLPathSelectAutomaton\fP* \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBatm\fP\fC [private]\fP"
.PP
XML select automaton used. 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBContext\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBcontext\fP\fC [private]\fP"
.PP
state variables without stacks of the automaton 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBArray\fP<unsigned int> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBfollows\fP\fC [private]\fP"
.PP
indices of tokens active in all descendant scopes 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBThisXMLScanner\fP \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBscan\fP\fC [private]\fP"
.PP
XML Scanner for fetching elements for the automaton input. 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBArray\fP<\fBScope\fP> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBscopestk\fP\fC [private]\fP"
.PP
stack of scopes opened 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBArray\fP<\fBToken\fP> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBtokens\fP\fC [private]\fP"
.PP
list of waiting tokens 
.SS "template<class InputIterator , class InputCharSet_ , class OutputCharSet_ , class OutputBuffer_ , class EntityMap_  = std::map<const char*,UChar>> \fBArray\fP<int> \fBtextwolf::XMLPathSelect\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBtriggers\fP\fC [private]\fP"
.PP
triggered elements 

.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
