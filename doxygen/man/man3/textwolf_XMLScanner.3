.TH "textwolf::XMLScanner" 3 "14 Aug 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::XMLScanner \- 
.PP
XML scanner template that adds the functionality to the statemachine base definition.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <textwolf.hpp>\fP
.PP
Inherits \fBtextwolf::XMLScannerBase\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBEnd\fP"
.br
.RI "\fIend of input tag \fP"
.ti -1c
.RI "class \fBiterator\fP"
.br
.RI "\fIinput iterator for iterating on the output of an XML scanner \fP"
.ti -1c
.RI "class \fBTokState\fP"
.br
.RI "\fIToken state variables. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef InputCharSet_ \fBInputCharSet\fP"
.br
.ti -1c
.RI "typedef OutputCharSet_ \fBOutputCharSet\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBTextScanner\fP< InputIterator, InputCharSet_ > \fBInputReader\fP"
.br
.ti -1c
.RI "typedef \fBXMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ > \fBThisXMLScanner\fP"
.br
.ti -1c
.RI "typedef EntityMap_ \fBEntityMap\fP"
.br
.ti -1c
.RI "typedef EntityMap::const_iterator \fBEntityMapIterator\fP"
.br
.ti -1c
.RI "typedef OutputBuffer_ \fBOutputBuffer\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBpush\fP (\fBUChar\fP ch)"
.br
.RI "\fIPrint a character to the output token buffer. \fP"
.ti -1c
.RI "void \fBfallbackEntity\fP ()"
.br
.RI "\fIPrint the characters of a sequence that was thought to form an entity but did not. \fP"
.ti -1c
.RI "bool \fBparseEntity\fP ()"
.br
.RI "\fITry to parse an entity (we got '&'). \fP"
.ti -1c
.RI "bool \fBparseNumericEntity\fP ()"
.br
.RI "\fITry to parse a numeric entity (we got '&#'). \fP"
.ti -1c
.RI "bool \fBparseNumericBaseEntity\fP ()"
.br
.RI "\fITry to parse a numeric entity with known base (we got '&#' and we know the base 10/16 of it). \fP"
.ti -1c
.RI "bool \fBparseNamedEntity\fP ()"
.br
.RI "\fITry to parse a named entity. \fP"
.ti -1c
.RI "bool \fBparseTokenRecover\fP ()"
.br
.RI "\fITry to recover from an interrupted token parsing state (end of input exception). \fP"
.ti -1c
.RI "bool \fBparseToken\fP (const \fBIsTokenCharMap\fP &isTok)"
.br
.RI "\fIParse a token defined by the set of valid token characters. \fP"
.ti -1c
.RI "bool \fBskipToken\fP (const \fBIsTokenCharMap\fP &isTok)"
.br
.RI "\fISkip a token defined by the set of valid token characters (same as parseToken but nothing written to the output buffer). \fP"
.ti -1c
.RI "bool \fBexpectStr\fP (const char *str)"
.br
.RI "\fIParse a token that must be the same as a given string. \fP"
.ti -1c
.RI "bool \fBpushPredefinedEntity\fP (const char *str)"
.br
.RI "\fIParse an entity defined by name (predefined). \fP"
.ti -1c
.RI "bool \fBpushEntity\fP (const char *str)"
.br
.RI "\fIParse an entity defined by name (predefined or in defined in entity table). \fP"
.ti -1c
.RI "\fBXMLScanner\fP (InputIterator &p_src, \fBOutputBuffer\fP &p_outputBuf, const \fBEntityMap\fP &p_entityMap)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBXMLScanner\fP (InputIterator &p_src, \fBOutputBuffer\fP &p_outputBuf)"
.br
.ti -1c
.RI "\fBXMLScanner\fP (\fBXMLScanner\fP &o)"
.br
.RI "\fICopy constructor. \fP"
.ti -1c
.RI "void \fBsetOutputBuffer\fP (\fBOutputBuffer\fP &p_outputBuf)"
.br
.RI "\fIRedefine the buffer to use for output. \fP"
.ti -1c
.RI "void \fBsetSource\fP (const InputIterator &itr)"
.br
.RI "\fIInitialize a new source iterator while keeping the state. \fP"
.ti -1c
.RI "const char * \fBgetItem\fP () const "
.br
.RI "\fIGet the current parsed XML element string, if it was not masked out, see \fBnextItem(unsigned short)\fP. \fP"
.ti -1c
.RI "\fBsize_type\fP \fBgetItemSize\fP () const "
.br
.RI "\fIGet the size of the current parsed YML element string in bytes. \fP"
.ti -1c
.RI "\fBScannerStatemachine::Element\fP * \fBgetState\fP ()"
.br
.RI "\fIGet the current XML scanner state machine state. \fP"
.ti -1c
.RI "\fBError\fP \fBgetError\fP (const char **str=0)"
.br
.RI "\fIGet the last error. \fP"
.ti -1c
.RI "\fBElementType\fP \fBnextItem\fP (unsigned short mask=0xFFFF)"
.br
.RI "\fIScan the next XML element. \fP"
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP (bool doSkipToFirst=true)"
.br
.RI "\fIGet begin iterator. \fP"
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.RI "\fIGet the pointer to the end of content. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static unsigned char \fBHEX\fP (unsigned char ch)"
.br
.RI "\fIMap a hexadecimal digit to its value. \fP"
.ti -1c
.RI "static \fBUChar\fP \fBparseStaticNumericEntityValue\fP (\fBInputReader\fP &ir)"
.br
.RI "\fIParse a numeric entity value for a table definition (map it to the target character set). \fP"
.ti -1c
.RI "template<class OutputBufferType > static bool \fBparseStaticToken\fP (const \fBIsTokenCharMap\fP &isTok, \fBInputReader\fP ir, OutputBufferType &buf)"
.br
.RI "\fIStatic version of parse a token for parsing table definition elements. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBTokState\fP \fBtokstate\fP"
.br
.RI "\fIthe entity parsing state of this XML scanner \fP"
.ti -1c
.RI "\fBSTMState\fP \fBstate\fP"
.br
.RI "\fIcurrent state of the XML scanner \fP"
.ti -1c
.RI "\fBError\fP \fBerror\fP"
.br
.RI "\fIlast error code \fP"
.ti -1c
.RI "\fBInputReader\fP \fBm_src\fP"
.br
.RI "\fIsource input iterator \fP"
.ti -1c
.RI "const \fBEntityMap\fP * \fBm_entityMap\fP"
.br
.RI "\fImap with entities defined by the caller \fP"
.ti -1c
.RI "\fBOutputBuffer\fP * \fBm_outputBuf\fP"
.br
.RI "\fIbuffer to use for output \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> class textwolf::XMLScanner< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >"
XML scanner template that adds the functionality to the statemachine base definition. 

\fBTemplate Parameters:\fP
.RS 4
\fIInputIterator\fP input iterator with ++ and read only * returning 0 als last character of the input 
.br
\fIInputCharSet_\fP character set encoding of the input, read as stream of bytes 
.br
\fIOutputCharSet_\fP character set encoding of the output, printed as string of the item type of the character set, 
.br
\fIOutputBuffer_\fP buffer for output with STL back insertion sequence interface (e.g. std::string,std::vector<char>,\fBtextwolf::StaticBuffer\fP) 
.br
\fIEntityMap_\fP STL like map from ASCII const char* to UChar 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef EntityMap_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBEntityMap\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef EntityMap::const_iterator \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBEntityMapIterator\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef InputCharSet_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBInputCharSet\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef \fBTextScanner\fP<InputIterator,InputCharSet_> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBInputReader\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef OutputBuffer_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBOutputBuffer\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef OutputCharSet_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBOutputCharSet\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef unsigned int \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBsize_type\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> typedef \fBXMLScanner\fP<InputIterator,InputCharSet_,OutputCharSet_,OutputBuffer_,EntityMap_> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBThisXMLScanner\fP"
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLScanner\fP (InputIterator & p_src, \fBOutputBuffer\fP & p_outputBuf, const \fBEntityMap\fP & p_entityMap)\fC [inline]\fP"
.PP
Constructor. \fBParameters:\fP
.RS 4
\fIp_src\fP source iterator 
.br
\fIp_outputBuf\fP buffer to use for output 
.br
\fIp_entityMap\fP read only map of named entities defined by the user 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLScanner\fP (InputIterator & p_src, \fBOutputBuffer\fP & p_outputBuf)\fC [inline]\fP"
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBXMLScanner\fP (\fBXMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ > & o)\fC [inline]\fP"
.PP
Copy constructor. \fBParameters:\fP
.RS 4
\fIo\fP scanner to copy 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::begin (bool doSkipToFirst = \fCtrue\fP)\fC [inline]\fP"
.PP
Get begin iterator. \fBReturns:\fP
.RS 4
iterator 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdoSkipToFirst\fP true, if the iterator should skip to the first character of the input (default behaviour of STL conform iterators but maybe not exception save) 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::end ()\fC [inline]\fP"
.PP
Get the pointer to the end of content. \fBReturns:\fP
.RS 4
iterator 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::expectStr (const char * str)\fC [inline]\fP"
.PP
Parse a token that must be the same as a given string. \fBParameters:\fP
.RS 4
\fIstr\fP string expected 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> void \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::fallbackEntity ()\fC [inline]\fP"
.PP
Print the characters of a sequence that was thought to form an entity but did not. \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBError\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::getError (const char ** str = \fC0\fP)\fC [inline]\fP"
.PP
Get the last error. \fBParameters:\fP
.RS 4
\fIstr\fP the error as string 
.RE
.PP
\fBReturns:\fP
.RS 4
the error code 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> const char* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::getItem () const\fC [inline]\fP"
.PP
Get the current parsed XML element string, if it was not masked out, see \fBnextItem(unsigned short)\fP. \fBReturns:\fP
.RS 4
the item string 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBsize_type\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::getItemSize () const\fC [inline]\fP"
.PP
Get the size of the current parsed YML element string in bytes. \fBReturns:\fP
.RS 4
the item string 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBScannerStatemachine::Element\fP* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::getState ()\fC [inline]\fP"
.PP
Get the current XML scanner state machine state. \fBReturns:\fP
.RS 4
pointer to the state variables 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> static unsigned char \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::HEX (unsigned char ch)\fC [inline, static]\fP"
.PP
Map a hexadecimal digit to its value. \fBParameters:\fP
.RS 4
\fIch\fP hexadecimal digit to map to its decimal value 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBElementType\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::nextItem (unsigned short mask = \fC0xFFFF\fP)\fC [inline]\fP"
.PP
Scan the next XML element. \fBParameters:\fP
.RS 4
\fImask\fP element types that should be printed to the output buffer (1 -> print, 0 -> mask out, just return the element as event) 
.RE
.PP
\fBReturns:\fP
.RS 4
the type of the XML element 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseEntity ()\fC [inline]\fP"
.PP
Try to parse an entity (we got '&'). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseNamedEntity ()\fC [inline]\fP"
.PP
Try to parse a named entity. \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseNumericBaseEntity ()\fC [inline]\fP"
.PP
Try to parse a numeric entity with known base (we got '&#' and we know the base 10/16 of it). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseNumericEntity ()\fC [inline]\fP"
.PP
Try to parse a numeric entity (we got '&#'). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> static \fBUChar\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseStaticNumericEntityValue (\fBInputReader\fP & ir)\fC [inline, static]\fP"
.PP
Parse a numeric entity value for a table definition (map it to the target character set). \fBParameters:\fP
.RS 4
\fIir\fP input reader 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the entity parsed 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> template<class OutputBufferType > static bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseStaticToken (const \fBIsTokenCharMap\fP & isTok, \fBInputReader\fP ir, OutputBufferType & buf)\fC [inline, static]\fP"
.PP
Static version of parse a token for parsing table definition elements. \fBTemplate Parameters:\fP
.RS 4
\fIOutputBufferType\fP type buffer for output 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.br
\fIir\fP input reader iterator 
.br
\fIbuf\fP buffer where to write the result to 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseToken (const \fBIsTokenCharMap\fP & isTok)\fC [inline]\fP"
.PP
Parse a token defined by the set of valid token characters. \fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::parseTokenRecover ()\fC [inline]\fP"
.PP
Try to recover from an interrupted token parsing state (end of input exception). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> void \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::push (\fBUChar\fP ch)\fC [inline]\fP"
.PP
Print a character to the output token buffer. \fBParameters:\fP
.RS 4
\fIch\fP unicode character to print 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::pushEntity (const char * str)\fC [inline]\fP"
.PP
Parse an entity defined by name (predefined or in defined in entity table). \fBParameters:\fP
.RS 4
\fIstr\fP pointer to the buffer with the entity name 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::pushPredefinedEntity (const char * str)\fC [inline]\fP"
.PP
Parse an entity defined by name (predefined). \fBParameters:\fP
.RS 4
\fIstr\fP pointer to the buffer with the entity name 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> void \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::setOutputBuffer (\fBOutputBuffer\fP & p_outputBuf)\fC [inline]\fP"
.PP
Redefine the buffer to use for output. \fBParameters:\fP
.RS 4
\fIp_outputBuf\fP buffer to use for output 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> void \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::setSource (const InputIterator & itr)\fC [inline]\fP"
.PP
Initialize a new source iterator while keeping the state. \fBParameters:\fP
.RS 4
\fIitr\fP source iterator 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::skipToken (const \fBIsTokenCharMap\fP & isTok)\fC [inline]\fP"
.PP
Skip a token defined by the set of valid token characters (same as parseToken but nothing written to the output buffer). \fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBError\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBerror\fP\fC [private]\fP"
.PP
last error code 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> const \fBEntityMap\fP* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBm_entityMap\fP\fC [private]\fP"
.PP
map with entities defined by the caller 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBOutputBuffer\fP* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBm_outputBuf\fP\fC [private]\fP"
.PP
buffer to use for output 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBInputReader\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBm_src\fP\fC [private]\fP"
.PP
source input iterator 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBSTMState\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBstate\fP\fC [private]\fP"
.PP
current state of the XML scanner 
.SS "template<class InputIterator, class InputCharSet_, class OutputCharSet_, class OutputBuffer_, class EntityMap_ = std::map<const char*,UChar>> \fBTokState\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, OutputBuffer_, EntityMap_ >::\fBtokstate\fP\fC [private]\fP"
.PP
the entity parsing state of this XML scanner 

.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
