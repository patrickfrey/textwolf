.TH "textwolf::ScannerStatemachine" 3 "14 Aug 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::ScannerStatemachine \- 
.PP
Class to build up the XML element scanner state machine in a descriptive way.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <textwolf.hpp>\fP
.PP
Inherits \fBtextwolf::throws_exception\fP.
.PP
Inherited by \fBtextwolf::XMLScannerBase::Statemachine\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBElement\fP"
.br
.RI "\fIOne state in the state machine. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum { \fBMaxNofStates\fP = 64 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBElement\fP * \fBget\fP (int stateIdx)  throw (exception)"
.br
.RI "\fIGet state addressed by its index. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP ()"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBoperator[]\fP (int stateIdx)"
.br
.RI "\fISee \fBScannerStatemachine::newState(int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBoperator()\fP (\fBControlCharacter\fP inputchr, int ns)"
.br
.RI "\fISee \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBoperator()\fP (\fBControlCharacter\fP i1, \fBControlCharacter\fP i2, int ns)"
.br
.RI "\fISee \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBoperator()\fP (\fBControlCharacter\fP i1, \fBControlCharacter\fP i2, \fBControlCharacter\fP i3, int ns)"
.br
.RI "\fISee \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBoperator()\fP (\fBControlCharacter\fP inputchr)"
.br
.RI "\fISee \fBScannerStatemachine::addTransition(ControlCharacter)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBaction\fP (int aa, int arg=0)"
.br
.RI "\fISee \fBScannerStatemachine::addAction(int,int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBmiss\fP (int ee)"
.br
.RI "\fISee \fBScannerStatemachine::addMiss(int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBfallback\fP (int stateIdx)"
.br
.RI "\fISee \fBScannerStatemachine::addFallback(int)\fP. \fP"
.ti -1c
.RI "\fBScannerStatemachine\fP & \fBother\fP (int stateIdx)"
.br
.RI "\fISee \fBScannerStatemachine::addOtherTransition(int)\fP. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBnewState\fP (int stateIdx)  throw (exception)"
.br
.RI "\fICreate a new state. \fP"
.ti -1c
.RI "void \fBaddOtherTransition\fP (int nextState)  throw (exception)"
.br
.RI "\fIDefine a transition for all control character types not firing yet in the last state defined. \fP"
.ti -1c
.RI "void \fBaddTransition\fP (\fBControlCharacter\fP inputchr, int nextState)  throw (exception)"
.br
.RI "\fIDefine a transition for inputchr in the last state defined. \fP"
.ti -1c
.RI "void \fBaddTransition\fP (\fBControlCharacter\fP inputchr)  throw (exception)"
.br
.RI "\fIDefine a self directing transition for inputchr in the last state defined (the state remains the same for this input). \fP"
.ti -1c
.RI "void \fBaddAction\fP (int action_op, int action_arg=0)  throw (exception)"
.br
.RI "\fIDefine an action in the last state defined (to be executed when entering the state). \fP"
.ti -1c
.RI "void \fBaddMiss\fP (int error)  throw (exception)"
.br
.RI "\fIDefine an error in the last state defined to be reported when no fallback is defined and no firing input character parsed. \fP"
.ti -1c
.RI "void \fBaddFallback\fP (int stateIdx)  throw (exception)"
.br
.RI "\fIDefine in the last state defined a fallback state transition that is fired when no firing input character parsed. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBElement\fP \fBtab\fP [MaxNofStates]"
.br
.RI "\fIstates of the STM \fP"
.ti -1c
.RI "unsigned int \fBsize\fP"
.br
.RI "\fInumber of states defined in the STM \fP"
.in -1c
.SH "Detailed Description"
.PP 
Class to build up the XML element scanner state machine in a descriptive way. 
.SH "Member Enumeration Documentation"
.PP 
.SS "anonymous enum"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMaxNofStates \fP\fP
maximum number of states (fixed allocated array for state machine) 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "textwolf::ScannerStatemachine::ScannerStatemachine ()\fC [inline]\fP"
.PP
Constructor. 
.SH "Member Function Documentation"
.PP 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::action (int aa, int arg = \fC0\fP)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addAction(int,int)\fP. 
.SS "void textwolf::ScannerStatemachine::addAction (int action_op, int action_arg = \fC0\fP)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define an action in the last state defined (to be executed when entering the state). \fBParameters:\fP
.RS 4
\fIaction_op\fP action operand 
.br
\fIaction_arg\fP action argument 
.RE
.PP

.SS "void textwolf::ScannerStatemachine::addFallback (int stateIdx)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define in the last state defined a fallback state transition that is fired when no firing input character parsed. \fBParameters:\fP
.RS 4
\fIstateIdx\fP follow state index 
.RE
.PP

.SS "void textwolf::ScannerStatemachine::addMiss (int error)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define an error in the last state defined to be reported when no fallback is defined and no firing input character parsed. \fBParameters:\fP
.RS 4
\fIerror\fP code to be reported 
.RE
.PP

.SS "void textwolf::ScannerStatemachine::addOtherTransition (int nextState)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define a transition for all control character types not firing yet in the last state defined. \fBParameters:\fP
.RS 4
\fInextState\fP the follow state index defined for these transitions 
.RE
.PP

.SS "void textwolf::ScannerStatemachine::addTransition (\fBControlCharacter\fP inputchr)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define a self directing transition for inputchr in the last state defined (the state remains the same for this input). \fBParameters:\fP
.RS 4
\fIinputchr\fP the firing input control character type 
.RE
.PP

.SS "void textwolf::ScannerStatemachine::addTransition (\fBControlCharacter\fP inputchr, int nextState)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Define a transition for inputchr in the last state defined. \fBParameters:\fP
.RS 4
\fIinputchr\fP the firing input control character type 
.br
\fInextState\fP the follow state index defined for this transition 
.RE
.PP

.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::fallback (int stateIdx)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addFallback(int)\fP. 
.SS "\fBElement\fP* textwolf::ScannerStatemachine::get (int stateIdx)  throw (\fBexception\fP)\fC [inline]\fP"
.PP
Get state addressed by its index. \fBParameters:\fP
.RS 4
\fIstateIdx\fP index of the state 
.RE
.PP
\fBReturns:\fP
.RS 4
state defintion reference 
.RE
.PP

.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::miss (int ee)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addMiss(int)\fP. 
.SS "void textwolf::ScannerStatemachine::newState (int stateIdx)  throw (\fBexception\fP)\fC [inline, private]\fP"
.PP
Create a new state. \fBParameters:\fP
.RS 4
\fIstateIdx\fP index of the state (must be the size of the STM array, so that state identifiers can be named by enumeration constants for better readability) 
.RE
.PP

.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::operator() (\fBControlCharacter\fP inputchr)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addTransition(ControlCharacter)\fP. 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::operator() (\fBControlCharacter\fP i1, \fBControlCharacter\fP i2, \fBControlCharacter\fP i3, int ns)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::operator() (\fBControlCharacter\fP i1, \fBControlCharacter\fP i2, int ns)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::operator() (\fBControlCharacter\fP inputchr, int ns)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addTransition(ControlCharacter,int)\fP. 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::operator[] (int stateIdx)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::newState(int)\fP. 
.SS "\fBScannerStatemachine\fP& textwolf::ScannerStatemachine::other (int stateIdx)\fC [inline]\fP"
.PP
See \fBScannerStatemachine::addOtherTransition(int)\fP. 
.SH "Member Data Documentation"
.PP 
.SS "unsigned int \fBtextwolf::ScannerStatemachine::size\fP\fC [private]\fP"
.PP
number of states defined in the STM 
.SS "\fBElement\fP \fBtextwolf::ScannerStatemachine::tab\fP[MaxNofStates]\fC [private]\fP"
.PP
states of the STM 

.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
