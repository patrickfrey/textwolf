.TH "textwolf::XMLScanner" 3 "11 Jun 2011" "textwolf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
textwolf::XMLScanner \- 
.PP
XML scanner template that adds the functionality to the statemachine base definition.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <textwolf.hpp>\fP
.PP
Inherits \fBtextwolf::XMLScannerBase\fP.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBEnd\fP"
.br
.RI "\fIend of input tag \fP"
.ti -1c
.RI "class \fBIsContentCharMap\fP"
.br
.RI "\fIDefines the set of content token characters. \fP"
.ti -1c
.RI "class \fBIsDQStringCharMap\fP"
.br
.RI "\fIDefines the set characters belonging to a double quoted string. \fP"
.ti -1c
.RI "class \fBIsSQStringCharMap\fP"
.br
.RI "\fIDefines the set characters belonging to a single quoted string. \fP"
.ti -1c
.RI "class \fBIsTagCharMap\fP"
.br
.RI "\fIDefines the set of tag characters. \fP"
.ti -1c
.RI "class \fBiterator\fP"
.br
.RI "\fIinput iterator for iterating on the output of an XML scanner \fP"
.ti -1c
.RI "class \fBTokState\fP"
.br
.RI "\fIToken state variables. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef InputCharSet_ \fBInputCharSet\fP"
.br
.ti -1c
.RI "typedef OutputCharSet_ \fBOutputCharSet\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBTextScanner\fP< InputIterator, InputCharSet_ > \fBInputReader\fP"
.br
.ti -1c
.RI "typedef \fBXMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ > \fBThisXMLScanner\fP"
.br
.ti -1c
.RI "typedef EntityMap_ \fBEntityMap\fP"
.br
.ti -1c
.RI "typedef EntityMap::iterator \fBEntityMapIterator\fP"
.br
.ti -1c
.RI "typedef \fBCharMap\fP< bool, false, NofControlCharacter > \fBIsTokenCharMap\fP"
.br
.RI "\fIForms a set of characters by assigning (true/false) to the whole domain. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "unsigned int \fBprint\fP (\fBUChar\fP ch)"
.br
.RI "\fIPrint a character to the output token buffer. \fP"
.ti -1c
.RI "bool \fBpush\fP (\fBUChar\fP ch)"
.br
.RI "\fIPrint a character to the output token buffer with incrementing the buffer used size. \fP"
.ti -1c
.RI "bool \fBfallbackEntity\fP ()"
.br
.RI "\fIPrint the characters of a sequence that was thought to form an entity but did not. \fP"
.ti -1c
.RI "bool \fBparseEntity\fP ()"
.br
.RI "\fITry to parse an entity (we got '&'). \fP"
.ti -1c
.RI "bool \fBparseNumericEntity\fP ()"
.br
.RI "\fITry to parse a numeric entity (we got '&#'). \fP"
.ti -1c
.RI "bool \fBparseNumericBaseEntity\fP ()"
.br
.RI "\fITry to parse a numeric entity with known base (we got '&#' and we know the base 10/16 of it). \fP"
.ti -1c
.RI "bool \fBparseNamedEntity\fP ()"
.br
.RI "\fITry to parse a named entity. \fP"
.ti -1c
.RI "bool \fBparseTokenRecover\fP ()"
.br
.RI "\fITry to recover from an interrupted token parsing state (end of input exception). \fP"
.ti -1c
.RI "bool \fBparseToken\fP (const \fBIsTokenCharMap\fP &isTok)"
.br
.RI "\fIParse a token defined by the set of valid token characters. \fP"
.ti -1c
.RI "bool \fBskipToken\fP (const \fBIsTokenCharMap\fP &isTok)"
.br
.RI "\fISkip a token defined by the set of valid token characters (same as parseToken but nothing written to the output buffer). \fP"
.ti -1c
.RI "bool \fBexpectStr\fP (const char *str)"
.br
.RI "\fIParse a token that must be the same as a given string. \fP"
.ti -1c
.RI "bool \fBpushPredefinedEntity\fP (const char *str)"
.br
.RI "\fIParse an entity defined by name (predefined). \fP"
.ti -1c
.RI "bool \fBpushEntity\fP (const char *str)"
.br
.RI "\fIParse an entity defined by name (predefined or in defined in entity table). \fP"
.ti -1c
.RI "\fBXMLScanner\fP (InputIterator &p_src, char *p_outputBuf, \fBsize_type\fP p_outputBufSize, \fBEntityMap\fP *p_entityMap=0)"
.br
.RI "\fIConstructor. \fP"
.ti -1c
.RI "\fBXMLScanner\fP (\fBXMLScanner\fP &o)"
.br
.RI "\fICopy constructor. \fP"
.ti -1c
.RI "void \fBsetOutputBuffer\fP (char *p_outputBuf, \fBsize_type\fP p_outputBufSize)"
.br
.RI "\fIRedefine the buffer to use for output. \fP"
.ti -1c
.RI "char * \fBgetItem\fP () const "
.br
.RI "\fIGet the current parsed YML element string, if it was not masked out, see \fBnextItem(unsigned short)\fP. \fP"
.ti -1c
.RI "\fBsize_type\fP \fBgetItemSize\fP () const "
.br
.RI "\fIGet the size of the current parsed YML element string in bytes. \fP"
.ti -1c
.RI "\fBScannerStatemachine::Element\fP * \fBgetState\fP ()"
.br
.RI "\fIGet the current XML scanner state machine state. \fP"
.ti -1c
.RI "\fBError\fP \fBgetError\fP (const char **str=0)"
.br
.RI "\fIGet the last error. \fP"
.ti -1c
.RI "\fBElementType\fP \fBnextItem\fP (unsigned short mask=0xFFFF)"
.br
.RI "\fIScan the next XML element. \fP"
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.RI "\fIGet begin iterator. \fP"
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.RI "\fIGet the pointer to the end of content. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static unsigned char \fBHEX\fP (unsigned char ch)"
.br
.RI "\fIMap a hexadecimal digit to its value. \fP"
.ti -1c
.RI "static \fBUChar\fP \fBparseStaticNumericEntityValue\fP (\fBInputReader\fP &ir)"
.br
.RI "\fIParse a numeric entity value for a table definition (map it to the target character set). \fP"
.ti -1c
.RI "static bool \fBparseStaticToken\fP (const \fBIsTokenCharMap\fP &isTok, \fBInputReader\fP ir, char *buf, \fBsize_type\fP bufsize, \fBsize_type\fP *p_outputBufSize)"
.br
.RI "\fIStatic version of parse a token for parsing table definition elements. \fP"
.ti -1c
.RI "template<class CharSet > static bool \fBgetTagName\fP (const char *\fBsrc\fP, char *p_outputBuf, \fBsize_type\fP p_outputBufSize, \fBsize_type\fP *p_outputSize)"
.br
.RI "\fIStatic parse of a tag name for the elements in a table. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBTokState\fP \fBtokstate\fP"
.br
.RI "\fIthe entity parsing state of this XML scanner \fP"
.ti -1c
.RI "\fBSTMState\fP \fBstate\fP"
.br
.RI "\fIcurrent state of the XML scanner \fP"
.ti -1c
.RI "\fBError\fP \fBerror\fP"
.br
.RI "\fIlast error code \fP"
.ti -1c
.RI "\fBInputReader\fP \fBsrc\fP"
.br
.RI "\fIsource input iterator \fP"
.ti -1c
.RI "\fBEntityMap\fP * \fBentityMap\fP"
.br
.RI "\fImap with entities defined by the caller \fP"
.ti -1c
.RI "char * \fBoutputBuf\fP"
.br
.RI "\fIbuffer to use for output \fP"
.ti -1c
.RI "\fBsize_type\fP \fBoutputBufSize\fP"
.br
.RI "\fIsize of buffer to use for output \fP"
.ti -1c
.RI "\fBsize_type\fP \fBoutputSize\fP"
.br
.RI "\fInumber of bytes written to output buffer \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> class textwolf::XMLScanner< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >"
XML scanner template that adds the functionality to the statemachine base definition. 

\fBTemplate Parameters:\fP
.RS 4
\fIInputIterator\fP input iterator with ++ and read only * returning 0 als last character of the input 
.br
\fIInputCharSet_\fP character set encoding of the input, read as stream of bytes 
.br
\fIOutputCharSet_\fP character set encoding of the output, printed as string of the item type of the character set 
.br
\fIEntityMap_\fP STL like map from ASCII const char* to UChar 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef EntityMap_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBEntityMap\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef EntityMap::iterator \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBEntityMapIterator\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef InputCharSet_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBInputCharSet\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef \fBTextScanner\fP<InputIterator,InputCharSet_> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBInputReader\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBIsTokenCharMap\fP"
.PP
Forms a set of characters by assigning (true/false) to the whole domain. 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef OutputCharSet_ \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBOutputCharSet\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef unsigned int \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBsize_type\fP"
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> typedef \fBXMLScanner\fP<InputIterator,InputCharSet_,OutputCharSet_,EntityMap_> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBThisXMLScanner\fP"
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBXMLScanner\fP (InputIterator & p_src, char * p_outputBuf, \fBsize_type\fP p_outputBufSize, \fBEntityMap\fP * p_entityMap = \fC0\fP)\fC [inline]\fP"
.PP
Constructor. \fBParameters:\fP
.RS 4
\fIp_src\fP source iterator 
.br
\fIp_outputBuf\fP buffer to use for output 
.br
\fIp_outputBufSize\fP size of buffer to use for output in bytes 
.br
\fIp_entityMap\fP read only map of named entities defined by the user 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBXMLScanner\fP (\fBXMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ > & o)\fC [inline]\fP"
.PP
Copy constructor. \fBParameters:\fP
.RS 4
\fIo\fP scanner to copy 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::begin ()\fC [inline]\fP"
.PP
Get begin iterator. \fBReturns:\fP
.RS 4
iterator 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBiterator\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::end ()\fC [inline]\fP"
.PP
Get the pointer to the end of content. \fBReturns:\fP
.RS 4
iterator 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::expectStr (const char * str)\fC [inline]\fP"
.PP
Parse a token that must be the same as a given string. \fBParameters:\fP
.RS 4
\fIstr\fP string expected 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::fallbackEntity ()\fC [inline]\fP"
.PP
Print the characters of a sequence that was thought to form an entity but did not. \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBError\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::getError (const char ** str = \fC0\fP)\fC [inline]\fP"
.PP
Get the last error. \fBParameters:\fP
.RS 4
\fIstr\fP the error as string 
.RE
.PP
\fBReturns:\fP
.RS 4
the error code 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> char* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::getItem () const\fC [inline]\fP"
.PP
Get the current parsed YML element string, if it was not masked out, see \fBnextItem(unsigned short)\fP. \fBReturns:\fP
.RS 4
the item string 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBsize_type\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::getItemSize () const\fC [inline]\fP"
.PP
Get the size of the current parsed YML element string in bytes. \fBReturns:\fP
.RS 4
the item string 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBScannerStatemachine::Element\fP* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::getState ()\fC [inline]\fP"
.PP
Get the current XML scanner state machine state. \fBReturns:\fP
.RS 4
pointer to the state variables 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> template<class CharSet > static bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::getTagName (const char * src, char * p_outputBuf, \fBsize_type\fP p_outputBufSize, \fBsize_type\fP * p_outputSize)\fC [inline, static]\fP"
.PP
Static parse of a tag name for the elements in a table. \fBTemplate Parameters:\fP
.RS 4
\fICharacter\fP set of the tag written 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP tagname as ASCII with encoded entities for characters beyond ASCII 
.br
\fIp_outputBuf\fP buffer for output 
.br
\fIp_outputBufSize\fP size of buffer for output in bytes 
.br
\fIp_outputSize\fP number of bytes written to output in bytes 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> static unsigned char \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::HEX (unsigned char ch)\fC [inline, static]\fP"
.PP
Map a hexadecimal digit to its value. \fBParameters:\fP
.RS 4
\fIch\fP hexadecimal digit to map to its decimal value 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBElementType\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::nextItem (unsigned short mask = \fC0xFFFF\fP)\fC [inline]\fP"
.PP
Scan the next XML element. \fBParameters:\fP
.RS 4
\fImask\fP element types that should be printed to the output buffer (1 -> print, 0 -> mask out, just return the element as event) 
.RE
.PP
\fBReturns:\fP
.RS 4
the type of the XML element 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseEntity ()\fC [inline]\fP"
.PP
Try to parse an entity (we got '&'). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseNamedEntity ()\fC [inline]\fP"
.PP
Try to parse a named entity. \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseNumericBaseEntity ()\fC [inline]\fP"
.PP
Try to parse a numeric entity with known base (we got '&#' and we know the base 10/16 of it). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseNumericEntity ()\fC [inline]\fP"
.PP
Try to parse a numeric entity (we got '&#'). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> static \fBUChar\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseStaticNumericEntityValue (\fBInputReader\fP & ir)\fC [inline, static]\fP"
.PP
Parse a numeric entity value for a table definition (map it to the target character set). \fBParameters:\fP
.RS 4
\fIir\fP input reader 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the entity parsed 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> static bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseStaticToken (const \fBIsTokenCharMap\fP & isTok, \fBInputReader\fP ir, char * buf, \fBsize_type\fP bufsize, \fBsize_type\fP * p_outputBufSize)\fC [inline, static]\fP"
.PP
Static version of parse a token for parsing table definition elements. \fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.br
\fIir\fP input reader iterator 
.br
\fIbuf\fP buffer where to write the result to 
.br
\fIbufsize\fP allocation size of buf in bytes 
.br
\fIp_outputBufSize\fP number of bytes written to buf 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseToken (const \fBIsTokenCharMap\fP & isTok)\fC [inline]\fP"
.PP
Parse a token defined by the set of valid token characters. \fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::parseTokenRecover ()\fC [inline]\fP"
.PP
Try to recover from an interrupted token parsing state (end of input exception). \fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> unsigned int \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::print (\fBUChar\fP ch)\fC [inline]\fP"
.PP
Print a character to the output token buffer. \fBParameters:\fP
.RS 4
\fIch\fP unicode character to print 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::push (\fBUChar\fP ch)\fC [inline]\fP"
.PP
Print a character to the output token buffer with incrementing the buffer used size. \fBParameters:\fP
.RS 4
\fIch\fP unicode character to print 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::pushEntity (const char * str)\fC [inline]\fP"
.PP
Parse an entity defined by name (predefined or in defined in entity table). \fBParameters:\fP
.RS 4
\fIstr\fP pointer to the buffer with the entity name 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::pushPredefinedEntity (const char * str)\fC [inline]\fP"
.PP
Parse an entity defined by name (predefined). \fBParameters:\fP
.RS 4
\fIstr\fP pointer to the buffer with the entity name 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> void \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::setOutputBuffer (char * p_outputBuf, \fBsize_type\fP p_outputBufSize)\fC [inline]\fP"
.PP
Redefine the buffer to use for output. \fBParameters:\fP
.RS 4
\fIp_outputBuf\fP buffer to use for output 
.br
\fIp_outputBufSize\fP size of buffer to use for output in bytes 
.RE
.PP

.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> bool \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::skipToken (const \fBIsTokenCharMap\fP & isTok)\fC [inline]\fP"
.PP
Skip a token defined by the set of valid token characters (same as parseToken but nothing written to the output buffer). \fBParameters:\fP
.RS 4
\fIisTok\fP set of valid token characters 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBEntityMap\fP* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBentityMap\fP\fC [private]\fP"
.PP
map with entities defined by the caller 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBError\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBerror\fP\fC [private]\fP"
.PP
last error code 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> char* \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBoutputBuf\fP\fC [private]\fP"
.PP
buffer to use for output 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBsize_type\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBoutputBufSize\fP\fC [private]\fP"
.PP
size of buffer to use for output 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBsize_type\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBoutputSize\fP\fC [private]\fP"
.PP
number of bytes written to output buffer 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBInputReader\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBsrc\fP\fC [private]\fP"
.PP
source input iterator 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBSTMState\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBstate\fP\fC [private]\fP"
.PP
current state of the XML scanner 
.SS "template<class InputIterator, class InputCharSet_ = charset::UTF8, class OutputCharSet_ = charset::UTF8, class EntityMap_ = std::map<const char*,UChar>> \fBTokState\fP \fBtextwolf::XMLScanner\fP< InputIterator, InputCharSet_, OutputCharSet_, EntityMap_ >::\fBtokstate\fP\fC [private]\fP"
.PP
the entity parsing state of this XML scanner 

.SH "Author"
.PP 
Generated automatically by Doxygen for textwolf from the source code.
